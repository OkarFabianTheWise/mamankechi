## ğŸ“ **Lecture Title: Rust Fundamentals I â€“ Learning Rust Like Mamankechi in the Market**

### â±ï¸ Duration: 30 minutes  
### ğŸ‘¥ Audience: Beginner blockchain devs  
### ğŸ§  Objective: Understand Rustâ€™s ownership model, syntax, control flow, and error handling using everyday examples.

---

## ğŸ•’ **Minute 0â€“3: Introduction**
- Quick intro: Rust is the main language for Solana smart contracts.
- Why Rust? Safe, fast, and memory-efficient.
- Letâ€™s learn Rust like weâ€™re in Mamankechiâ€™s market stall or a school classroom!

---

## ğŸ•’ **Minute 4â€“12: Ownership & Memory Management**

### ğŸ”§ Concept: Ownership (Core of Rust)

**Scenario: Mamankechiâ€™s Basket of Tomatoes**  
Mamankechi sells tomatoes. She gives her basket to her assistant, Musa.

```rust
let basket = String::from("Tomatoes");
let musa = basket; // basket is MOVED to Musa
```

- â— *basket* is no longer valid. Only Musa owns the tomatoes now.
- This is called **"move semantics"** in Rust.
- Why? So we donâ€™t have two people fighting over the same tomatoes!

### âœ‹ What if Mamankechi still wants access?

```rust
let basket = String::from("Tomatoes");
let musa = &basket; // Borrowing
```

- Musa borrows the basket. Mamankechi still owns it. No fight!
- This is called **"borrowing"** â€“ very useful!

### ğŸ¤“ Summary:
- Only one owner at a time.
- Borrowing lets others *use* but not *own*.
- Rust enforces this at compile time â€“ no surprise bugs.

---

## ğŸ•’ **Minute 13â€“18: Basic Syntax, Variables & Data Types**

### ğŸ§‘ğŸ¾â€ğŸ« School Setting: Teacher records student scores

```rust
let mut score = 70; // mutable variable
score = 85;
```

- `let` defines variables.
- `mut` allows us to change them.

### ğŸ“Š Data Types: Just like school data

```rust
let name = "Chinedu";      // &str
let age: u8 = 14;          // unsigned 8-bit integer
let is_present = true;     // boolean
let average: f32 = 75.5;   // float
```

- Rust needs to **know the type** of each variable.
- If Rust knows what to expect, it avoids "surprises" like bad data.

### ğŸ“ Notes:
- Rust is **statically typed**. Think of it like a strict head teacher.

---

## ğŸ•’ **Minute 19â€“24: Control Flow**

### ğŸ’µ Scenario: ATM withdrawal at a traditional bank

```rust
let balance = 5000;

if balance > 1000 {
    println!("Withdrawal Approved");
} else {
    println!("Insufficient Balance");
}
```

- Control flow with `if`, `else` â€“ like checks at an ATM.

### ğŸŒ€ Loops â€“ Market restocking example

```rust
let mut stock = 5;

while stock > 0 {
    println!("Selling an item. Remaining: {}", stock);
    stock -= 1;
}
```

- Repeats until stock finishes.
- Rust also has `loop`, `for`, etc.

---

## ğŸ•’ **Minute 25â€“30: Error Handling**

### âš ï¸ Scenario: Teacher checking if student submitted homework

```rust
fn check_homework(name: &str) -> Result<&str, &str> {
    if name == "Ada" {
        Ok("Submitted")
    } else {
        Err("Not Submitted")
    }
}
```

```rust
let result = check_homework("Chuka");

match result {
    Ok(msg) => println!("âœ… {}", msg),
    Err(msg) => println!("âŒ {}", msg),
}
```

- `Result<T, E>` is Rustâ€™s way of handling errors.
- No crashing like in Python or JS â€“ you *must* handle the error!

---

## ğŸ Wrap Up (1 min)

### Key Takeaways:
- **Ownership** keeps things safe. No double-spending tomatoes!
- **Rust syntax** is strict but powerful.
- **Control flow** makes decisions and loops.
- **Error handling** in Rust makes your code robust.

---

### âœ… Bonus Homework:
> Recreate the ATM withdrawal logic in Rust but ask for a PIN. If itâ€™s wrong, print an error.
